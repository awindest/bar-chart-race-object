<!DOCTYPE html>
<head>
   <title>Bar Chart Race Object</title>
   <meta charset="utf-8">
   <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.1/d3.min.js"></script>
   import {Runtime, Inspector, Library} from "https://cdn.jsdelivr.net/npm/@observablehq/runtime@4/dist/runtime.js";

   <style>
   text{
      font-size: 16px;
      font-family: Open Sans, sans-serif;
   }
    text.title{
       font-size: 24px;
       font-weight: 500;
    }
    text.subTitle{
       font-weight: 500;
       fill: #777777;
    }
    text.caption{
       font-weight: 400;
       font-size: 14px;
       fill: #777777;
    }
    text.label{
       font-weight: 600;
    }

    text.valueLabel{
       font-weight: 300;
    }

    text.yearText{
       font-size: 64px;
       font-weight: 700;
       opacity: 0.25;
    }
    .tick text {
       fill: #777777;
    }
    .xAxis .tick:nth-child(2) text {
       text-anchor: start;
    }
    .tick line {
       shape-rendering: CrispEdges;
       stroke: #dddddd;
    }
    .tick line.origin{
       stroke: #aaaaaa;
    }
    path.domain{
       display: none;
    }
   </style>
</head>

<body>
<script>
//global variables
let datevalues
const margin = ({top: 16, right: 6, bottom: 6, left: 0})
const barSize= 48
const n = 12 // number of bars to expose in the chart
const top_n = 12;
//let height = 600;
const height = margin.top + barSize * n + margin.bottom
const width = 960;

const duration = 500

const k = 10 // interpolation range for animating bars so they won't jump around

// time animation - needs to be global

const x = d3.scaleLinear([0, 1], [margin.left, width - margin.right])

const y = d3.scaleBand()
    .domain(d3.range(n + 1))
    .rangeRound([margin.top, margin.top + barSize * (n + 1 + 0.1)])
    .padding(0.1)

//initvis method
const svg = d3.select("body").append("svg")
   .attr("width", width)
   .attr("height", height);

const barPadding = (height-(margin.bottom+margin.top))/(top_n*5);

const title = svg.append('text')
   .attr('class', 'title')
   .attr('y', 24)
   .html('Source Systems');

const subTitle = svg.append("text")
   .attr("class", "subTitle")
   .attr("y", 55)
   .html("# Rows or Objects Processed, $m");

const formatDate = d3.timeFormat("%Y-%m-%d")


d3.csv('category-brands.csv', d3.autoType).then(function(data) {
   /* Schema: 0: {date: '2000-01-01', name: 'Coca-Cola', category: 'Beverages', value: '72537'} */
   //if (error) throw error;

   data.forEach(d => { //cleansing actions
         d.date = formatDate(d.date),
         d.value = isNaN(d.value) ? 0 : d.value
   })

   console.log('here\'s data:', data)
   console.log('got data', data)

   const barcolor = () => {
      const scale = d3.scaleOrdinal(d3.schemeTableau10)
      if (data.some(d => d.category !== undefined)) {
         const categoryByName = new Map(data.map(d => [d.name, d.category]))
         scale.domain(Array.from(categoryByName.values()))
         return d => scale(categoryByName.get(d.name))
      }
      return d => scale(d.name)
   }
   /* here's the full set of names (unique because Sets don't do duplicates). We sliced out the name value with the .map helper function */
   const names = new Set(data.map(d => d.name)) //used in rank
   /* here’s the set of dates (datevalues). We construct a nested map from date and name to value. 
   Then we convert this to an array to order the data chronologically. 
   (Note: Dates are objects, so we have to do a little dance to construct the map. 
   The dates are first coerced to numbers using + for keys, and then converted back 
   into dates using the Date constructor.)
   */
   datevalues = Array.from(d3.rollup(data, ([d]) => d.value, d => d.date, d => d.name))
      .map(([date, data]) => [new Date(date), data])
      .sort(([a], [b]) => d3.ascending(a, b))
   console.log('datevalues data: ',datevalues)


const bars = (svg) => {
  let bar = svg.append("g")
      .attr("fill-opacity", 0.6)
    .selectAll("rect")
console.log('in bars(svg)')
  return ([date, data], transition) => bar = bar
    .data(data.slice(0, n), d => d.name)
    .join(
      enter => enter.append("rect")
        .attr("fill", barcolor())
        .attr("height", y.bandwidth())
        .attr("x", x(0))
        .attr("y", d => y((prev.get(d) || d).rank))
        .attr("width", d => x((prev.get(d) || d).value) - x(0)),
      update => update,
      exit => exit.transition(transition).remove()
        .attr("y", d => y((next.get(d) || d).rank))
        .attr("width", d => x((next.get(d) || d).value) - x(0))
    )
    .call(bar => bar.transition(transition)
      .attr("y", d => y(d.rank))
      .attr("width", d => x(d.value) - x(0)))
}

const formatNumber = d3.format(",d") // used in textTween

function textTween(a, b) {
  const i = d3.interpolateNumber(a, b);
  return function(t) { //candidate for => pattern
    this.textContent = formatNumber(i(t))
  }
}
const labels = (svg) => {
  let label = svg.append("g")
      .style("font", "bold 12px var(--sans-serif)")
      .style("font-variant-numeric", "tabular-nums")
      .attr("text-anchor", "end")
    .selectAll("text")

  return ([date, data], transition) => label = label
    .data(data.slice(0, n), d => d.name)
    .join(
      enter => enter.append("text")
        .attr("transform", d => `translate(${x((prev.get(d) || d).value)},${y((prev.get(d) || d).rank)})`)
        .attr("y", y.bandwidth() / 2)
        .attr("x", -6)
        .attr("dy", "-0.25em")
        .text(d => d.name)
        .call(text => text.append("tspan")
          .attr("fill-opacity", 0.7)
          .attr("font-weight", "normal")
          .attr("x", -6)
          .attr("dy", "1.15em")),
      update => update,
      exit => exit.transition(transition).remove()
        .attr("transform", d => `translate(${x((next.get(d) || d).value)},${y((next.get(d) || d).rank)})`)
        .call(g => g.select("tspan").tween("text", d => textTween(d.value, (next.get(d) || d).value)))
    )
    .call(bar => bar.transition(transition)
      .attr("transform", d => `translate(${x(d.value)},${y(d.rank)})`)
      .call(g => g.select("tspan").tween("text", d => textTween((prev.get(d) || d).value, d.value))))
}

const axis = (svg) => {
  const g = svg.append("g")
      .attr("transform", `translate(0,${margin.top})`);

  const axis = d3.axisTop(x)
      .ticks(width / 160)
      .tickSizeOuter(0)
      .tickSizeInner(-barSize * (n + y.padding()));

  return (_, transition) => { // _ = whatever 8)
    g.transition(transition).call(axis)
    g.select(".tick:first-of-type text").remove()
    g.selectAll(".tick:not(:first-of-type) line").attr("stroke", "white")
    g.select(".domain").remove()
  }
}


/* Let's compute the zero-based rank for each brand. The rank function below takes a value accessor function, 
retrieves each brand’s value, sorts the result by descending value, and then assigns rank. We could add this to the data but
this way is more flexible. Here is sample output:
  0: Object {
  name: "Coca-Cola"
  value: 72537
  rank: 0
}*/
   const rank = (value) => {
      const data = Array.from(names, name => ({name, value: value(name)}));
      data.sort((a, b) => d3.descending(a.value, b.value));
      for (let i = 0; i < data.length; ++i) data[i].rank = Math.min(n, i);
      return data;
   }
/* Why bother with a value accessor function? Well, because we’re about to do something interesting.
Rank is an ordinal value: a brand can be rank 2 or 3, but never rank 2.345. In the source data, ranks 
change once per year. If we animated rank changes over the year (2.5 seconds), many bars would move 
up or down simultaneously, making the race hard to follow. Hence we generate interpolated frames 
within the year to animate rank changes more quickly (250 milliseconds), improving readability.

Try disabling interpolation by setting k to 1, then see how this affects the animation. 
Since our rank helper above takes a function, so we can use it to interpolate values linearly. 
If a is the starting value and b is the ending value, then we vary the parameter t∈[0,1] to compute 
the interpolated value a(1 - t) + bt. For any missing data—remember, turnover as some times our data may have gaps
— we treat the value as zero. */

 const getKeyframes = () => {
      const keyframes = []
      let ka, a, kb, b
      for ([[ka, a], [kb, b]] of d3.pairs(datevalues)) {
         for (let i = 0; i < k; ++i) {
            let t = i / k;
            keyframes.push([
               new Date(ka * (1 - t) + kb * t),
               rank(name => (a.get(name) || 0) * (1 - t) + (b.get(name) || 0) * t)
            ]);
         }
      }
      keyframes.push([new Date(kb), rank(name => b.get(name) || 0)])
      return keyframes
   }
let keyframes = getKeyframes()

let nameframes = d3.groups(keyframes.flatMap(([, data]) => data), d => d.name)
let prev = new Map(nameframes.flatMap(([, data]) => d3.pairs(data, (a, b) => [b, a])))
let next = new Map(nameframes.flatMap(([, data]) => d3.pairs(data)))
//const formatDisplayDate = d3.utcFormat("%d %m %Y")
const formatDisplayDate = d3.utcFormat("%Y")

const ticker = (svg) => {
  const now = svg.append("text")
      .style("font", `bold ${barSize}px var(--sans-serif)`)
      .style("font-variant-numeric", "tabular-nums")
      .attr("text-anchor", "end")
      .attr("x", width - 6)
      .attr("y", margin.top + barSize * (n - 0.45))
      .attr("dy", "0.32em")
      .text(formatDisplayDate(keyframes[0][0]));

  return ([date], transition) => {
      transition.end().then(() => now.text(formatDisplayDate(date))) //what does 'now' do? it is the problem child
  }
}
 // update method
const updateBars = bars(svg)
const updateAxis = axis(svg)
const updateLabels = labels(svg)
const updateTicker = ticker(svg)
let i = 0
// this is the loop where the chart is updated by keyframe
  for (const keyframe of keyframes) { // keyframes is a list
      const transition = () => svg.transition()
         .duration(duration)
         .ease(d3.easeLinear)
    // Extract the top bar’s value.
      x.domain([0, keyframe[1][0].value])
      updateAxis(keyframe, transition);
      updateBars(keyframe, transition);
      updateLabels(keyframe, transition);
      updateTicker(keyframe, transition);

      //invalidation.then(() => svg.interrupt())
      //transition.end()
   }

}) //end of resolved promise
.catch(error => {
      console.log(error)
    })
   </script>
</body>
